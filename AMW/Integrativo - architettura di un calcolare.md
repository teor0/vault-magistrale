#amw #magistrale 
[[Riepiloghi utili]]
# Livelli di astrazione in un calcolatore
Le architetture tradizionali dei computer possono essere viste come la composizione di vari strati o livelli di astrazione che nascondo i dettagli implementativi. Ad esempio su hardware eterogeneo posso decidere di eseguire Linux, Windows o BSD in quanto l'hardware sottostante viene astratto dal sistema operativo. Gli autori di malware scrivono programmi con linguaggi di alto livello per poi utilizzare i compilatori per generare codice macchina che viene eseguito dalla CPU. Gli analisti la contrario utilizzano un disassemblatore per generare codice assembly da analizzare per ricostruire il funzionamento dell'eseguibile. In generale questo modello semplice ha origine da una struttura a sei livelli di astrazione. Definiamo questa struttura a partire dal livello più basso:
- Hardware: è l'unico livello fisico e consiste nei circuiti elettrici che implementano le complesse combinazioni di più operatori logici come XOR, AND, OR e NOT.
- Firmware o micro code: è il primo livello software che incontriamo e funziona solamente sul circuito su cui viene progettato con cui si interfaccia tramite micro istruzioni.
- Codice macchina: il codice macchina consiste in numeri esadecimali (*opcodes*) che indicano al processore cosa fare. Viene generato dal compilatore a partire dal codice di linguaggi ad alto livello.
- Linguaggi a basso livello: un linguaggio a basso livello è una versione comprensibile dall'essere umano di istruzioni macchina di una architettura. Il più famoso è **assembly**. Un analista opera con assembly tramite un diasassembler per comprendere il funzionamento di un malware.
- Linguaggi a alto livello: sono i linguaggi comunemente utilizzati per programmare sistemi operativi o programmi in generale quali: C o C++. Più propriamente definiamo linguaggi a alto livello, linguaggi che vengono tradotti in codice macchina per mezzo di un **compilatore** quindi linguaggi compilati.
- Linguaggi interpretati: sono i linguaggi più evoluti come Java e Python dove il codice viene trasformato in bytecode che viene interpretato da interprete che ha il compito di tradurre il bytecode in codice macchina al volo in runtime. A differenza di un linguaggio compilato, un linguaggio interpretato offre capacità di gestione della memoria (esempio il garbage collector di Java) e gestione degli errori in maniera indipendente dal OS.

# Architettura x86, suoi componenti, istruzioni
L'architettura della maggior parte dei computer odierni, detta x86 è basata sull'architettura di Von Neumann come già detto e si basa su 3 componenti principali: CPU, RAM e I/O disposti come segue: 
![[x86architecture.png|400]]
L'unità di controllo della CPU prende le istruzioni da eseguire in RAM grazie ad un registro, <font color=red>l'istruction pointer</font> (EIP per architetture a 32 bit, mentre RIP per quelle a 64 bit) che mantiene al suo interno l'indirizzo dell'istruzione successiva da eseguire. I registri della CPU vengono utilizzati per effettuare i calcoli più rapidamente senza andare a recuperare i valori in memoria. L'ALU (arithmetic logic unit) esegue le istruzioni prese dalla RAM e mette il risultato nei registri. La memoria centrale o RAM per un singolo processo può essere suddivisa in 4 sezioni principali: stack, heap, code e data. 
![[sezioni_ram.png|300]]
Lo stack viene usato per memorizzare le variabili locali e i parametri di una funzione e gestire meglio il flusso di esecuzione di un programma. L'heap è usato come memoria dinamica durante l'esecuzione di un programma per allocare nuovi valori, e liberare celle con valori non più utilizzati. La sezione code, include le istruzioni prese dalla CPU per eseguire un programma. Infine la sezione data contiene dati che vengono creati quando un programma viene inizialmente caricato in memoria. Di solito questi dati non cambiano valore durante l'esecuzione e sono disponibili per qualsiasi porzione del programma.

Le istruzioni assembly sono composte da una parte detta *mnemonic* e zero o più operandi. Ad esempio l'istruzione `MOV ECX, 0x42` contiene il mnemonic MOV, e due operandi quali ECX e 0x42. Altri mnemonic sono ad esempio: ADD, PUSH, POP, SUB, JMP, ecc. Ricordiamo che assembly è **case insensitive**. Ogni istruzione assembly corrisponde ad uno o più codici operativi (numeri esadecimali) che indicano alla CPU quale operazione il programma vuole effettuare. Ad esempio all'istruzione `MOV ECX, 0x42` corrispondono i codici operativi 0xB9 o B9 per `MOV ECX` e 42 00 00 00 per 0x42 quindi con formato little endian.
Altre istruzioni che è utile ripassare sono i salti condizionali che elenchiamo di seguito:
![[jumps.png|400]]