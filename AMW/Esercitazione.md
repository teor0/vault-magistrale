#amw #magistrale  
[[Compilazione di un file sorgente, registri e funzionamento stack]]
# Esercizio 1 
Proviamo a capire il funzionamento del seguente codice assembly:
```assembly
	.text
	.section .rodata
.LC0:
	.string "Hello world!"
	.text
	.globl main
main:
	leal 4(%esp), %ecx
	andl $-16, %esp
	pushl -4(%ecx)
	pushl %EBP
	movl %esp, %EBP
	pushl %ecx
	subl $4, %esp 
	subl	$12, %esp 
	pushl $.LC0
	call puts
	addl $16, %esp
	movl $0, %eax
	movl -4(%ebp), $ecx
	leave
	leal -4(%ecx), %esp
	ret
```
il programma è un banale "Hello world!" stampato a video. Ma non c'è la printf() in quanto dato che non si usano stringhe di formato come ad esempio %f, il main utilizza `call puts` per stampare una semplice stringa. Ovviamente il programmatore in C avrà usato printf(), ma automaticamente il compilatore lo sostituisce con puts data la mancanza di stringhe formato. Il file è stato generato tramite `gcc -S` data la presenza data la presenza di  `.text` che indica al assembler di generare codice per la sezione text ed equivale alla direttiva `.section .text`. La seconda riga indica di mettere il codice nella sezione read only. Nella terza riga c'è una etichetta, più propriamente dato che inizia con un punto, questa etichetta è un etichetta locale generata dal compilatore per i suoi scopi. La quarta riga contiene la stringa "Hello World!" che sarà costante dato che è contenuta nella sezione read only grazie alla direttiva nella seconda riga. Nella quinta riga, si ricomincia a generare codice per la sezione text. Nella sesta riga, definisce l'etichetta main come globale, quindi visibile da tutte le unità di compilazione, non solo questo file. Settima riga è l'etichetta main per il main del programma C. 8° riga, si carica tramite LEA 4 byte ovvero il registro dello stack pointer più 4 nel registro ecx. Quindi tramite questa riga, ecx punta il primo parametro della funzione, che nel caso del main è *argc*
La 9° riga fa un and bit a bit tra -16, che in esadecimale sono 28 bit pari a f e 4 bit pari a 0 ovvero il meno significativo, ed il registro esp quindi vado a decrementare gli ultimi 4 bit di esp che si traduce in un incremento nello stack. Questa operazione serve ad allineare esp su multipli di 16 perché magari il compilatore lavora meglio se allineato a 16 bit. La 10° riga fa una push nello stack di ecx-4 perciò mette il return address. Le due istruzioni successive sono per il prologo della funzione. L'istruzione 13 fa una push sullo stack dell'indirizzo puntato da ecx, quindi il primo parametro. L'istruzione 14 e 15 fanno una sub da esp quindi si sposta sopra di 16 byte esp. L'istruzione successiva fa la push dell'indirizzo dell'etichetta LC0. La call puts chiama la stampa a video.
L'istruzione add serve per riallineare lo stack a 16 byte. La prima move mette 0 in EAX mentre la seconda MOV riallinea ECX con il primo parametro. Questo avviene perché magari ECX è stato "sporcato" da puts ed il compilatore così sta sicuro. La leave sappiamo a cosa corrisponde. Infine la leal finale serve a far puntare a esp al return address. Questo viene fatto per bilanciare lo stack dato che ret farà terminare la funzione.

Vediamo adesso la variante a 64 bit: ![[es1_code64.png|400]] molte istruzioni sono simili. La direttiva `.p2align 4` allinea lo stack ad un multiplo di $2^4=16$ byte. La sub e la add servono per allineare lo stack! Altra variante stavolta però generata da un disassembler in sintassi Intel: ![[es1_intel.png|400]] da notare come a sinistra ci siano gli indirizzi e successivamente i codici operativi delle rispettive istruzioni assembly, come ad esempio C3 per RET e C9 per LEAVE.

# Esercizio 2
Vediamo adesso il codice di un altro programma: ![[es2_code.png|300]] come nel esercizio precedente si fanno varie configurazioni prima del main e poi si allinea nuovamente lo stack a 16 byte e si fa un prologo. Poi si fanno push dei registri `edi, esi, ebx`. Questi registri vanno preservati da un'esecuzione all'altra. Poi si fa `push %ecx` per via dell'allineamento. La sub serve anche ad allineare, in particolare si allinea di $8*4=32 byte$ ovvero appunto 6 push. La prima MOV serve a mettere il valore del primo parametro in ESI, mentre la seconda MOV serve a mettere il valore del secondo parametro in EDI. Poi si usa l'istruzione `TEST` e JLE ovvero jump se $\le$ quindi questo è in if. Attenzione che il test ritorna 1 dato che confronta ESI con se stesso.
Per quanto riguarda `L3` la prima sub è per allineare. La prima push mette sullo stack il primo elemento dell'array *argv*, che ricordiamo è l'indirizzo di una stringa. Poi fa la push di `L0` che è una funzione che fa la print dell'argomento i-esimo e la sua stringa puntata. La call torna dato che è stata fatta la push. La successiva add serve per allineare. La CMP ricordiamo è una comparazione non bit a bit ma per sottrazione. Questa comparazione serve per verificare che l'indice del ciclo di stampa (perché questo è il funzionamento del programma) non abbia superato la dimensione del vettore. Se ciò non accade infatti si ha `JNE .L3` un jump condizionale.
Anche per questo esercizio visioniamo la variante a 64 bit: ![[es2_code64.png|300]] in questo caso anche si fanno push di registri da preservare quali `r12, rbp, rbx`. Da notare l'istruzione `movslq %edi, %rbp` dove si mette il contenuto di edi in rbp estendendolo, quindi preservando il segno. Anche in questo caso si ha un ciclo ma stavolta l'indice è `rbx` e viene spostato di 8 in quanto i puntatori a 64 bit sono a 8 byte, ricordiamolo.

# Esercizio 3
Di seguito si propone codice assembly ottenuto tramite disassembler: ![[es3_code.png]] come per gli altri esercizi ci sono operazioni per allineare lo stack e il prologo. Ci sono poi delle push per preservare i registri `edi, esi, ebx` mentre l'unico parametro è puntato da `ecx`. Si ha poi una sub per allineare e dopo si sposta il contenuto di ecx ovvero il primo parametro in `edx`. Successivamente si prende dal registro basso `dl` i bit meno significativi e si copiano su `eax` tramite `movsx` che estende il segno del valore contenuto in `dl`. Quindi si ha un byte solo significativo ed i restanti 3 byte estesi che rappresentano il segno. In C un byte con il segno corrisponde ad un char! Quindi l'argomento passato alla funzione `a` è un char. Successivamente si fa push di eax e si fa una call alla funzione `a`. Dopo la call avviene `MOVSX ECX, AL` quindi il contenuto di AL viene esteso e copiato in ECX, di nuovo un byte con segno perciò la funzione `a` ritorna un char. Il prototipo della funzione è quindi `char a(char p)`. Andando a vedere il codice di `a` si vede come la funzione vada a prendere il primo parametro, grazie a `[ESP+0x04]` come un puntatore a un byte che è come abbiamo ipotizzato. Tale byte viene copia su EAX tramite MOVZX che non fa estensione del segno. Subito dopo si fa una add di un bit a EAX. Ma assieme a MOVZX comunque come abbiamo visto nel codice del main il bit di riporto sarà totalmente ignorato dato che poi si copierà solo il contenuto di AL. La funzione `a` inoltre è cdecl dato non pulisce lo stack ma sarà quindi il main a prendere la responsabilità di pulire lo stack. Ma tale pulizia non avviene! Dopo la call della funzione si hanno 3 MOV che servono a preparare il parametro della funzione `b` o meglio la seconda istruzione e la terza, `MOV EAX,DX` `MOV DWORD PTR [ESP],EAX` preparano lo stack pointer con il contenuto di EAX che si capisce essere a 2 byte, dato che si copia il contenuto di DX registro a 16 bit, appunto 2 byte quindi probabilmente corrisponde ad uno short.  Dopo la call di b si usa l'istruzione `CWDE` che serve a convertire una word in double word in particolare estendere con segno di 16 bit il registro AX per riempire EAX. Quindi il valore di ritorno della funzione è a 16 bit (2 byte) perciò il valore di ritorno della funzione è anch'esso uno short. Il prototipo della funzione è quindi `short a(short s)`. Guardando il contenuto della funzione si ha lo stesso funzionamento di `a` quindi le stesse considerazioni. Per quanto riguarda le funzioni `c` e `d` non possiamo dire nulla sul segno o il tipo di dati che ricevono come parametro se non che ricevono 4 byte come parametro, il registro `edx` e per il risultato anche non possiamo dire nulla solamente guardando il main. La funzione `e` viene preparata a riceve i propri parametri attraverso le istruzioni che la precedono. Particolare attenzione poniamo su `CDQ` che converte una Double word in Quad word quindi si preparano 64 bit! Nel dettaglio l'istruzione sta raddoppiando il contenuto del registro EDX, o meglio lo sta sovrascrivvendo con il segno di EAX, i 32 bit superiori raddoppiati quindi 64 bit. Ma siccome EDX è a 32 bit conterrà solo il segno esteso per tutti e 32 i bit. Poi si mette sullo stack e poi si fa una push di EAX. Quindi si stanno passando 64 bit alla funzione `e`. Potrebbe quindi essere che la funzione abbia due parametri oppure uno solo con il segno. La cosa più probabile è che stia mettendo un solo parametro ma a 64 bit. Il risultato della funzione sarà contenuto in EAX e EBX in quanto a 64 bit. Quindi il prototipo della funzione `e` è `long long e(long long p)`. Anche per questa funzione come per tutte le altre si fa aggiunge uno al parametro passato come input e si ritorna il risultato.

Tutti gli esercizi con il codice disassemblato sono frutto del tool `objdump` del compilatore gcc. 